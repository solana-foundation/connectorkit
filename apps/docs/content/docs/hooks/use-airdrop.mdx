---
title: useAirdrop
description: Hook for requesting SOL airdrops on devnet/testnet with retry logic
---

# useAirdrop

The `useAirdrop` hook provides an easy way to request SOL airdrops on development networks. It includes intelligent retry logic and fallback RPC endpoints for reliability.

## Usage

### Direct Import
```tsx
import { useAirdrop } from '@connectorkit/hooks'

function MyComponent() {
  const { 
    requestAirdrop, 
    isLoading, 
    addressInput,
    amountInput,
    setAddressInput,
    setAmountInput,
    handleSubmit 
  } = useAirdrop()
  
  const handleAirdrop = async () => {
    try {
      const result = await requestAirdrop('your-address-here', BigInt(1000000000)) // 1 SOL
      console.log('Airdrop successful:', result.signature)
    } catch (error) {
      console.error('Airdrop failed:', error)
    }
  }
  
  return (
    <div>
      <button onClick={handleAirdrop} disabled={isLoading}>
        {isLoading ? 'Requesting...' : 'Request 1 SOL'}
      </button>
    </div>
  )
}
```

### Copy Hook Code
If you prefer to copy the hook directly:

```tsx
'use client'

import { useMutation } from '@tanstack/react-query'
import { useCallback, useEffect, useState } from 'react'
import { useWallet, useNetwork } from '../core/arc-provider'
import { getSharedRpc, releaseRpcConnection } from '../core/rpc-manager'
import { type Address, type Lamports } from '@solana/kit'

function normalizeAddress(input: string | Address): string {
  if (typeof input === 'string') {
    const trimmed = input.trim()
    if (trimmed.length < 32) {
      throw new Error(`Invalid address format: ${input}`)
    }
    return trimmed
  }

  if (input && typeof input === 'object') {
    const candidateViaBase58 =
      // @ts-ignore - best-effort detection for PublicKey-like objects
      typeof (input as any).toBase58 === 'function' ? (input as any).toBase58() : undefined
    if (candidateViaBase58 && typeof candidateViaBase58 === 'string') {
      const trimmed = candidateViaBase58.trim()
      if (trimmed.length >= 32) return trimmed
    }

    // Common Address-like patterns: toString that yields base58, or an `address` string field
    const candidateViaToString = typeof (input as any).toString === 'function' ? (input as any).toString() : undefined
    if (candidateViaToString && typeof candidateViaToString === 'string' && candidateViaToString !== '[object Object]') {
      const trimmed = candidateViaToString.trim()
      if (trimmed.length >= 32) return trimmed
    }

    const candidateViaProp = typeof (input as any).address === 'string' ? (input as any).address : undefined
    if (candidateViaProp && typeof candidateViaProp === 'string') {
      const trimmed = candidateViaProp.trim()
      if (trimmed.length >= 32) return trimmed
    }
  }

  throw new Error(`Invalid address format: ${String(input)}`)
}

export interface AirdropResult {
  signature: string
  amount: Lamports
}

export interface UseAirdropReturn {
  requestAirdrop: (address: string | Address, amount?: Lamports) => Promise<AirdropResult>
  isLoading: boolean
  error: Error | null
  data: AirdropResult | null
  reset: () => void
  addressInput: string
  amountInput: string
  setAddressInput: (value: string) => void
  setAmountInput: (value: string) => void
  handleAddressInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  handleAmountInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  handleSubmit: (event?: { preventDefault?: () => void }) => Promise<AirdropResult | undefined>
  airdropFromInputs: () => Promise<AirdropResult | undefined>
}

export function useAirdrop(
  initialAddressInput: string = '',
  initialAmountInput: string = '1'
): UseAirdropReturn {
  const wallet = useWallet()
  const network = useNetwork()
  
  const [addressInput, setAddressInput] = useState(initialAddressInput || wallet.address || '')
  const [amountInput, setAmountInput] = useState(initialAmountInput)
  
  useEffect(() => {
    if (!addressInput && wallet.address) {
      setAddressInput(wallet.address)
    }
  }, [wallet.address, addressInput])

  useEffect(() => {
    return () => {
      releaseRpcConnection(network.rpcUrl)
    }
  }, [network.rpcUrl])

  const mutation = useMutation({
    mutationKey: ['airdrop'],
    mutationFn: async ({ address, amount = BigInt(1000000000) as Lamports }: { 
      address: string | Address; 
      amount?: Lamports 
    }): Promise<AirdropResult> => {
      try {
        const normalizedAddress = normalizeAddress(address)
        
        if (network.isMainnet) {
          throw new Error('Airdrops are not available on mainnet')
        }
        
        const rpcEndpoints = [
          network.rpcUrl,
          'https://devnet.helius-rpc.com/?api-key=5cfda7df-93e4-495e-918b-7e880a0dad7f',
          'https://rpc.ankr.com/solana_devnet',
          'https://solana-devnet.g.alchemy.com/v2/demo',
          'https://api.testnet.solana.com'
        ]
        
        const retryAirdrop = async (maxRetries = 8, initialDelay = 1000): Promise<string> => {
          let lastError: any = null
          
          for (let i = 0; i < maxRetries; i++) {
            const rpcUrl = rpcEndpoints[i % rpcEndpoints.length]
            const currentRpc = getSharedRpc(rpcUrl) as any // Cast to any for airdrop method access
            
            try {
              
              if (i > 0) {
                const jitter = Math.random() * 500
                const delay = Math.min(initialDelay * Math.pow(1.3, i), 8000) + jitter
                await new Promise(resolve => setTimeout(resolve, delay))
              }
              
              const adjustedAmount = i > 3 ? (amount / BigInt(2)) as Lamports : amount
              
              const signature = await currentRpc.requestAirdrop(normalizedAddress, adjustedAmount).send()
              return signature
              
            } catch (error: any) {
              lastError = error
              const errorMsg = error?.message || error?.toString() || 'Unknown error'
              
              if (errorMsg.includes('429') || errorMsg.includes('rate') || errorMsg.includes('Too Many Requests')) {
                continue
              } else if (errorMsg.includes('airdrop') && (errorMsg.includes('limit') || errorMsg.includes('exceeded'))) {
                continue
              } else if (errorMsg.includes('Invalid account') || errorMsg.includes('account not found')) {
                continue
              } else if (errorMsg.includes('timeout') || errorMsg.includes('network')) {
                continue
              } else {
              }
            }
          }
          
          const errorMsg = lastError?.message || 'Unknown error'
          if (errorMsg.includes('rate') || errorMsg.includes('429')) {
            throw new Error(`Rate limited on all endpoints. Please wait a few minutes and try again, or use the manual faucet at https://faucet.solana.com`)
          } else if (errorMsg.includes('limit')) {
            throw new Error(`Daily airdrop limits reached. Please use the manual faucet at https://faucet.solana.com`)
          } else {
            throw new Error(`All airdrop attempts failed. Try the manual faucet at https://faucet.solana.com`)
          }
        }
        
        const signature = await retryAirdrop()
        
        await new Promise(resolve => setTimeout(resolve, 3000))
        
        return {
          signature,
          amount
        }
        
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error'
        
        throw error
      }
    },
  })

  const requestAirdrop = (address: string | Address, amount?: Lamports) => {
    const normalizedAddress = normalizeAddress(address)
    return mutation.mutateAsync({ address: normalizedAddress, amount })
  }

  const handleAddressInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setAddressInput(event.target.value)
  }, [])
  
  const handleAmountInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setAmountInput(event.target.value)
  }, [])
  
  const airdropFromInputs = useCallback(async () => {
    if (!addressInput) {
      throw new Error('Address is required for airdrop')
    }
    
    try {
      const amountInLamports = amountInput ? 
        BigInt(Math.floor(parseFloat(amountInput) * 1_000_000_000)) as Lamports :
        BigInt(1_000_000_000) as Lamports
      
      return await mutation.mutateAsync({
        address: normalizeAddress(addressInput),
        amount: amountInLamports,
      })
    } catch (error) {
      console.error('Failed to parse amount or request airdrop:', error)
      throw error
    }
  }, [addressInput, amountInput, mutation.mutateAsync])
  
  const handleSubmit = useCallback(async (event?: { preventDefault?: () => void }) => {
    event?.preventDefault?.()
    return addressInput ? airdropFromInputs() : undefined
  }, [addressInput, airdropFromInputs])

  return {
    requestAirdrop,
    isLoading: mutation.isPending,
    error: mutation.error,
    data: mutation.data || null,
    reset: mutation.reset,
    addressInput,
    amountInput,
    setAddressInput,
    setAmountInput,
    handleAddressInputChange,
    handleAmountInputChange,
    handleSubmit,
    airdropFromInputs,
  }
}
```

## Parameters

- `initialAddressInput?: string` - Initial value for address input (default: '')
- `initialAmountInput?: string` - Initial value for amount input in SOL (default: '1')

## Return Value

### Core Functions
- `requestAirdrop: (address: string | Address, amount?: Lamports) => Promise<AirdropResult>` - Request airdrop function
- `isLoading: boolean` - Whether an airdrop request is in progress
- `error: Error | null` - Any error that occurred
- `data: AirdropResult | null` - Last successful airdrop result
- `reset: () => void` - Reset the mutation state

### Form Helpers
- `addressInput: string` - Current address input value
- `amountInput: string` - Current amount input value (in SOL)
- `setAddressInput: (value: string) => void` - Set address input
- `setAmountInput: (value: string) => void` - Set amount input
- `handleAddressInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void` - Input change handler
- `handleAmountInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void` - Input change handler
- `handleSubmit: (event?: { preventDefault?: () => void }) => Promise<AirdropResult | undefined>` - Form submit handler
- `airdropFromInputs: () => Promise<AirdropResult | undefined>` - Request airdrop using current input values

## AirdropResult

- `signature: string` - Transaction signature
- `amount: Lamports` - Amount airdropped in lamports

## Example

### Basic Usage
```tsx
import { useAirdrop } from '@connectorkit/hooks'

function AirdropButton() {
  const { requestAirdrop, isLoading, error, data } = useAirdrop()

  const handleAirdrop = async () => {
    try {
      const result = await requestAirdrop(
        'your-address-here', 
        BigInt(2000000000) // 2 SOL in lamports
      )
      console.log('Airdrop successful:', result.signature)
    } catch (err) {
      console.error('Airdrop failed:', err)
    }
  }

  return (
    <div>
      <button onClick={handleAirdrop} disabled={isLoading}>
        {isLoading ? 'Requesting...' : 'Request 2 SOL'}
      </button>
      {error && <p style={{color: 'red'}}>Error: {error.message}</p>}
      {data && <p style={{color: 'green'}}>Success! Signature: {data.signature}</p>}
    </div>
  )
}
```

### With Form Inputs
```tsx
import { useAirdrop } from '@connectorkit/hooks'

function AirdropForm() {
  const { 
    addressInput,
    amountInput,
    setAddressInput,
    setAmountInput,
    handleSubmit,
    isLoading,
    error,
    data
  } = useAirdrop()

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Address:</label>
        <input 
          type="text"
          value={addressInput}
          onChange={(e) => setAddressInput(e.target.value)}
          placeholder="Enter wallet address"
          required
        />
      </div>
      
      <div>
        <label>Amount (SOL):</label>
        <input 
          type="number"
          value={amountInput}
          onChange={(e) => setAmountInput(e.target.value)}
          placeholder="Amount in SOL"
          step="0.1"
          min="0.1"
          max="5"
          required
        />
      </div>
      
      <button type="submit" disabled={isLoading || !addressInput || !amountInput}>
        {isLoading ? 'Requesting...' : 'Request Airdrop'}
      </button>
      
      {error && (
        <div style={{ color: 'red', marginTop: '10px' }}>
          Error: {error.message}
        </div>
      )}
      
      {data && (
        <div style={{ color: 'green', marginTop: '10px' }}>
          Success! Airdropped {Number(data.amount) / 1e9} SOL
          <br />
          Signature: {data.signature}
        </div>
      )}
    </form>
  )
}
```

### Connected Wallet Airdrop
```tsx
import { useAirdrop } from '@connectorkit/hooks'
import { useWallet } from '@connectorkit/hooks'

function WalletAirdrop() {
  const { address, connected } = useWallet()
  const { requestAirdrop, isLoading } = useAirdrop()

  const handleAirdrop = async () => {
    if (!address) return
    
    try {
      await requestAirdrop(address, BigInt(1000000000)) // 1 SOL
      alert('Airdrop successful!')
    } catch (error) {
      alert(`Airdrop failed: ${error.message}`)
    }
  }

  if (!connected) {
    return <p>Please connect your wallet first</p>
  }

  return (
    <div>
      <p>Wallet: {address}</p>
      <button onClick={handleAirdrop} disabled={isLoading}>
        {isLoading ? 'Requesting...' : 'Airdrop 1 SOL to My Wallet'}
      </button>
    </div>
  )
}
```

### With Network Check
```tsx
import { useAirdrop } from '@connectorkit/hooks'
import { useCluster } from '@connectorkit/hooks'

function SmartAirdrop() {
  const { cluster, canAirdrop } = useCluster()
  const { requestAirdrop, isLoading } = useAirdrop()

  const handleAirdrop = async () => {
    if (!canAirdrop) {
      alert('Airdrops are only available on devnet/testnet')
      return
    }

    try {
      await requestAirdrop('your-address', BigInt(1000000000))
    } catch (error) {
      console.error('Airdrop failed:', error)
    }
  }

  return (
    <div>
      <p>Current network: {cluster}</p>
      {canAirdrop ? (
        <button onClick={handleAirdrop} disabled={isLoading}>
          Request Airdrop
        </button>
      ) : (
        <p>Airdrops not available on {cluster}</p>
      )}
    </div>
  )
}
```

### Multiple Airdrops
```tsx
import { useAirdrop } from '@connectorkit/hooks'

function BatchAirdrop() {
  const { requestAirdrop, isLoading } = useAirdrop()
  const [addresses, setAddresses] = useState(['', '', ''])

  const handleBatchAirdrop = async () => {
    const validAddresses = addresses.filter(addr => addr.trim())
    
    try {
      const promises = validAddresses.map(address => 
        requestAirdrop(address, BigInt(500000000)) // 0.5 SOL each
      )
      
      const results = await Promise.all(promises)
      console.log('All airdrops successful:', results)
    } catch (error) {
      console.error('Batch airdrop failed:', error)
    }
  }

  return (
    <div>
      <h3>Batch Airdrop</h3>
      {addresses.map((address, index) => (
        <input
          key={index}
          value={address}
          onChange={(e) => {
            const newAddresses = [...addresses]
            newAddresses[index] = e.target.value
            setAddresses(newAddresses)
          }}
          placeholder={`Address ${index + 1}`}
        />
      ))}
      <button onClick={handleBatchAirdrop} disabled={isLoading}>
        {isLoading ? 'Sending...' : 'Airdrop 0.5 SOL to Each'}
      </button>
    </div>
  )
}
```

## Notes

- Airdrops only work on devnet, testnet, and localnet
- The hook includes automatic retry logic with multiple RPC endpoints
- Rate limiting is handled gracefully with informative error messages
- Amounts are reduced automatically if initial requests fail
- The hook includes a 3-second delay after successful airdrop for confirmation
---
title: useSwap
description: Hook for executing token swaps across multiple DEX providers
---

import { SwapDemo } from '@/components/swap-demo'

# useSwap

The `useSwap` hook provides functionality to get quotes and execute token swaps across multiple decentralized exchange (DEX) providers. It supports aggregating quotes from different sources and executing swaps with the best available rates.

## Interactive Demo

Try the `useSwap` hook in action:

<SwapDemo />

## Usage

### Direct Import
```tsx
import { useSwap } from '@connectorkit/hooks'

function SwapInterface() {
  const {
    getQuotes,
    executeSwap,
    selectQuote,
    quotes,
    selectedQuote,
    isLoading,
    error
  } = useSwap({
    providers: ['jupiter', 'raydium'],
    strategy: 'best-price',
    maxSlippage: 0.5
  })

  const handleSwap = async () => {
    try {
      // Get quotes for swapping 1 SOL to USDC
      const quotes = await getQuotes({
        inputMint: 'So11111111111111111111111111111111111111112', // SOL
        outputMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
        amount: 1000000000, // 1 SOL in lamports
        slippageBps: 50 // 0.5%
      })

      // Execute the best quote
      if (quotes.length > 0) {
        const result = await executeSwap(quotes[0])
        console.log('Swap completed:', result.signature)
      }
    } catch (err) {
      console.error('Swap failed:', err)
    }
  }

  return (
    <div>
      <button onClick={handleSwap} disabled={isLoading}>
        {isLoading ? 'Swapping...' : 'Swap Tokens'}
      </button>
      {error && <div>Error: {error.message}</div>}
    </div>
  )
}
```

### Copy Hook Code
```tsx
'use client'

import { useState } from 'react'
import { useMutation } from '@tanstack/react-query'
import { useArcClient } from '../core/arc-client-provider'
import type { SwapParams, SwapQuote } from '../core/provider'
import type { SwapState } from '../types'
import { useTransaction, type TransactionConfig, type Instruction } from './use-transaction'
import type { SwapBuild } from '../core/provider'

export interface UseSwapReturn extends SwapState {
  getQuotes: (params: SwapParams) => Promise<SwapQuote[]>
  executeSwap: (quote: SwapQuote) => Promise<{ signature: string; confirmed: boolean }>
  selectQuote: (quote: SwapQuote) => void
}

export interface UseSwapOptions {
  providers?: string[]
  strategy?: 'best-price' | 'fastest' | 'lowest-fees'
  maxSlippage?: number
}

export function useSwap(options: UseSwapOptions = {}): UseSwapReturn {
  const { config, wallet } = useArcClient()
  const { sendTransaction, sendPrebuilt } = useTransaction({
    confirmationStrategy: 'confirmed',
    skipPreflight: false
  })
  
  const [selectedQuote, setSelectedQuote] = useState<SwapQuote | null>(null)
  
  const quoteMutation = useMutation({
    mutationFn: async (params: SwapParams): Promise<SwapQuote[]> => {
      const swapProviders = config.providers?.flatMap(p => p.swap || []) || []
      const filteredProviders = options.providers 
        ? swapProviders.filter(p => options.providers!.includes(p.name))
        : swapProviders
      
      const quotePromises = filteredProviders.map(provider => 
        provider.quote(params).catch(err => {
          console.warn(`Quote failed for ${provider.name}:`, err)
          return null
        })
      )
      
      const quotes = await Promise.all(quotePromises)
      return quotes.filter(Boolean) as SwapQuote[]
    },
  })

  const swapMutation = useMutation({
    mutationFn: async (quote: SwapQuote) => {
      const swapProviders = config.providers?.flatMap(p => p.swap || []) || []
      const provider = swapProviders.find(p => p.name === quote.provider)
      
      if (!provider) {
        throw new Error(`Provider ${quote.provider} not found`)
      }
      
      const build = await provider.build({ 
        quote, 
        userPublicKey: wallet.address as string,
        capabilities: wallet.capabilities
      }) as SwapBuild
      let result
      if (build.kind === 'instructions') {
        result = await sendTransaction({ 
          instructions: build.instructions as Instruction[],
          config: {
            skipPreflight: false,
            maxRetries: 3
          }
        })
      } else {
        result = await sendPrebuilt(build.transaction, {
          skipPreflight: false,
          maxRetries: 3
        })
      }
      
      return result
    },
  })

  const selectBestQuote = (quotes: SwapQuote[], strategy: string): SwapQuote => {
    switch (strategy) {
      case 'best-price':
        return quotes.reduce((best, current) => 
          current.outputAmount > best.outputAmount ? current : best
        )
      case 'fastest':
        return quotes.reduce((best, current) => 
          current.priceImpact < best.priceImpact ? current : best
        )
      case 'lowest-fees':
        return quotes.reduce((best, current) => 
          current.fees < best.fees ? current : best
        )
      default:
        return quotes[0]
    }
  }

  return {
    isLoading: quoteMutation.isPending || swapMutation.isPending,
    error: quoteMutation.error || swapMutation.error,
    quotes: quoteMutation.data || [],
    selectedQuote,
    getQuotes: async (params: SwapParams) => {
      const quotes = await quoteMutation.mutateAsync(params)
      if (quotes.length > 0 && options.strategy) {
        const bestQuote = selectBestQuote(quotes, options.strategy)
        setSelectedQuote(bestQuote)
      }
      return quotes
    },
    executeSwap: async (quote: SwapQuote) => {
      const result = await swapMutation.mutateAsync(quote)
      setSelectedQuote(null)
      return result
    },
    selectQuote: (quote: SwapQuote) => {
      setSelectedQuote(quote)
    }
  }
}
```

## Parameters

### UseSwapOptions

- `providers?: string[]` - Array of provider names to use (e.g., ['jupiter', 'raydium'])
- `strategy?: 'best-price' | 'fastest' | 'lowest-fees'` - Strategy for selecting the best quote
- `maxSlippage?: number` - Maximum acceptable slippage percentage

### SwapParams (for getQuotes)

- `inputMint: string` - Mint address of the input token
- `outputMint: string` - Mint address of the output token
- `amount: number` - Amount to swap (in smallest token units)
- `slippageBps: number` - Slippage tolerance in basis points

## Return Value

- `getQuotes: (params: SwapParams) => Promise<SwapQuote[]>` - Function to get swap quotes
- `executeSwap: (quote: SwapQuote) => Promise<{ signature: string; confirmed: boolean }>` - Function to execute a swap
- `selectQuote: (quote: SwapQuote) => void` - Function to manually select a quote
- `isLoading: boolean` - Whether a quote or swap operation is in progress
- `error: Error | null` - Any error that occurred
- `quotes: SwapQuote[]` - Array of available quotes
- `selectedQuote: SwapQuote | null` - Currently selected quote

### SwapQuote

- `provider: string` - Name of the provider offering the quote
- `inputAmount: number` - Input amount
- `outputAmount: number` - Expected output amount
- `priceImpact: number` - Price impact percentage
- `fees: number` - Total fees for the swap
- `route: any[]` - Swap route information

## Example

```tsx
import { useSwap } from '@connectorkit/hooks'
import { useWalletAddress } from '@connectorkit/hooks'
import { useState } from 'react'

function TokenSwapInterface() {
  const { address: walletAddress } = useWalletAddress()
  const {
    getQuotes,
    executeSwap,
    selectQuote,
    quotes,
    selectedQuote,
    isLoading,
    error
  } = useSwap({
    providers: ['jupiter', 'raydium'],
    strategy: 'best-price'
  })

  const [inputMint, setInputMint] = useState('So11111111111111111111111111111111111111112') // SOL
  const [outputMint, setOutputMint] = useState('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v') // USDC
  const [amount, setAmount] = useState('1')
  const [slippage, setSlippage] = useState('0.5')

  const handleGetQuotes = async () => {
    try {
      const swapAmount = parseFloat(amount) * Math.pow(10, 9) // Assuming 9 decimals
      await getQuotes({
        inputMint,
        outputMint,
        amount: swapAmount,
        slippageBps: parseFloat(slippage) * 100 // Convert to basis points
      })
    } catch (err) {
      console.error('Failed to get quotes:', err)
    }
  }

  const handleExecuteSwap = async () => {
    if (!selectedQuote) return
    
    try {
      const result = await executeSwap(selectedQuote)
      console.log('Swap completed:', result)
    } catch (err) {
      console.error('Swap failed:', err)
    }
  }

  const formatAmount = (amount: number, decimals: number = 9) => {
    return (amount / Math.pow(10, decimals)).toFixed(6)
  }

  return (
    <div style={{ padding: '20px', maxWidth: '600px' }}>
      <h3>Token Swap</h3>
      
      <div style={{ marginBottom: '20px', display: 'grid', gap: '16px' }}>
        <div>
          <label>
            Input Token (Mint Address):
            <input
              type="text"
              value={inputMint}
              onChange={(e) => setInputMint(e.target.value)}
              style={{ 
                width: '100%', 
                padding: '8px', 
                marginTop: '4px',
                fontFamily: 'monospace',
                fontSize: '14px'
              }}
            />
          </label>
        </div>

        <div>
          <label>
            Output Token (Mint Address):
            <input
              type="text"
              value={outputMint}
              onChange={(e) => setOutputMint(e.target.value)}
              style={{ 
                width: '100%', 
                padding: '8px', 
                marginTop: '4px',
                fontFamily: 'monospace',
                fontSize: '14px'
              }}
            />
          </label>
        </div>

        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
          <div>
            <label>
              Amount:
              <input
                type="number"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
                step="0.000001"
                style={{ width: '100%', padding: '8px', marginTop: '4px' }}
              />
            </label>
          </div>
          <div>
            <label>
              Slippage (%):
              <input
                type="number"
                value={slippage}
                onChange={(e) => setSlippage(e.target.value)}
                step="0.1"
                style={{ width: '100%', padding: '8px', marginTop: '4px' }}
              />
            </label>
          </div>
        </div>

        <button
          onClick={handleGetQuotes}
          disabled={isLoading || !walletAddress}
          style={{
            padding: '12px',
            backgroundColor: isLoading || !walletAddress ? '#ccc' : '#2196F3',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: isLoading || !walletAddress ? 'not-allowed' : 'pointer'
          }}
        >
          {isLoading ? 'Getting Quotes...' : 'Get Quotes'}
        </button>
      </div>

      {!walletAddress && (
        <p style={{ color: '#f44336' }}>Please connect your wallet to swap tokens</p>
      )}

      {error && (
        <div style={{ 
          marginBottom: '16px',
          padding: '12px', 
          backgroundColor: '#ffebee', 
          border: '1px solid #f44336',
          borderRadius: '4px',
          color: '#d32f2f'
        }}>
          <strong>Error:</strong> {error.message}
        </div>
      )}

      {quotes.length > 0 && (
        <div style={{ marginBottom: '20px' }}>
          <h4>Available Quotes</h4>
          <div style={{ display: 'grid', gap: '12px' }}>
            {quotes.map((quote, index) => (
              <div 
                key={index}
                onClick={() => selectQuote(quote)}
                style={{ 
                  padding: '16px', 
                  border: selectedQuote === quote ? '2px solid #4CAF50' : '1px solid #ddd',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  backgroundColor: selectedQuote === quote ? '#f8fff8' : 'white'
                }}
              >
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                  <strong>{quote.provider}</strong>
                  {selectedQuote === quote && (
                    <span style={{ 
                      padding: '4px 8px',
                      backgroundColor: '#4CAF50',
                      color: 'white',
                      borderRadius: '3px',
                      fontSize: '12px'
                    }}>
                      Selected
                    </span>
                  )}
                </div>
                
                <div style={{ display: 'grid', gap: '4px', fontSize: '14px' }}>
                  <div>
                    <strong>Output:</strong> {formatAmount(quote.outputAmount)} tokens
                  </div>
                  <div>
                    <strong>Price Impact:</strong> {(quote.priceImpact * 100).toFixed(3)}%
                  </div>
                  <div>
                    <strong>Fees:</strong> {formatAmount(quote.fees)} tokens
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {selectedQuote && (
        <div style={{ marginBottom: '20px' }}>
          <h4>Selected Quote Summary</h4>
          <div style={{ 
            padding: '16px',
            backgroundColor: '#e8f5e8',
            border: '1px solid #4CAF50',
            borderRadius: '8px'
          }}>
            <p><strong>Provider:</strong> {selectedQuote.provider}</p>
            <p><strong>You'll receive:</strong> ~{formatAmount(selectedQuote.outputAmount)} tokens</p>
            <p><strong>Price Impact:</strong> {(selectedQuote.priceImpact * 100).toFixed(3)}%</p>
            <p><strong>Total Fees:</strong> {formatAmount(selectedQuote.fees)} tokens</p>
          </div>
          
          <button
            onClick={handleExecuteSwap}
            disabled={isLoading}
            style={{
              marginTop: '12px',
              padding: '12px 24px',
              backgroundColor: isLoading ? '#ccc' : '#4CAF50',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: isLoading ? 'not-allowed' : 'pointer',
              width: '100%'
            }}
          >
            {isLoading ? 'Executing Swap...' : 'Execute Swap'}
          </button>
        </div>
      )}
    </div>
  )
}
```

## Features

- **Multi-Provider Support**: Aggregates quotes from multiple DEX providers
- **Strategy Selection**: Choose the best quote based on price, speed, or fees
- **Automatic Quote Selection**: Optionally auto-select the best quote based on strategy
- **Flexible Execution**: Supports both instruction-based and pre-built transaction swaps
- **Error Handling**: Comprehensive error handling with graceful fallbacks

## Use Cases

- **DEX Aggregation**: Get the best prices across multiple exchanges
- **Trading Interfaces**: Build advanced trading UIs with quote comparison
- **Arbitrage Tools**: Find price differences across providers
- **Portfolio Management**: Execute optimal swaps for rebalancing

## Notes

- Requires configured swap providers in the ArcClient configuration
- Quote prices can change rapidly - execute swaps promptly after getting quotes
- Slippage tolerance should be set appropriately for market conditions
- Some providers may require additional setup or API keys
- Transaction fees (gas) are separate from swap fees shown in quotes
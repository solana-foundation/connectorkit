---
title: Provider Ecosystem
description: Providers are modular integrations that allow you to compose easily with DeFi protocols through a unified interface. They enable seamless interactions across different protocols while maintaining consistent APIs.
---

# Provider Ecosystem

The Arc provider ecosystem enables you to build applications that work seamlessly across multiple DeFi protocols. Each provider implements the same standardized interface, allowing you to switch between protocols or use multiple providers simultaneously.

## Architecture Overview

### Provider Interface
All providers implement the `SwapProvider` interface:

```tsx
interface SwapProvider {
  name: string
  quote(params: SwapParams): Promise<SwapQuote>
  build(params: BuildParams): Promise<SwapBuild>
  isTokenSupported(mint: string): boolean
}
```

### How Providers Work

1. **Quote Phase**: Providers fetch pricing and routing information from their respective protocols
2. **Build Phase**: Providers construct the necessary transactions for execution
3. **Token Support**: Providers validate which tokens they can handle

### Integration with Hooks

Providers integrate seamlessly with Arc's hooks system:

```tsx
import { createJupiter } from '@arc/jupiter'
import { useSwap } from '@connectorkit/hooks'

function MySwapComponent() {
  const provider = createJupiter({ slippageBps: 50 })
  const { quote, swap } = useSwap({ provider })
  
  // Use quote() and swap() as needed
}
```

## Use Cases

### Multi-DEX Routing
Compare quotes across protocols to find the best prices:

```tsx
const providers = [
  createJupiter({ slippageBps: 50 }),
  // createRaydium({ slippageBps: 50 }),  // Future
  // createOrca({ slippageBps: 50 }),     // Future
]

const bestQuote = await findBestQuote(providers, {
  inputMint: 'SOL_MINT',
  outputMint: 'USDC_MINT', 
  amount: 1_000_000_000n
})
```

### Protocol Abstraction
Switch between DEXs without changing application code:

```tsx
// Same component works with any provider
function SwapWidget({ provider }: { provider: SwapProvider }) {
  const { quote, swap } = useSwap({ provider })
  // Implementation remains the same
}

// Use with different providers
<SwapWidget provider={createJupiter()} />
<SwapWidget provider={createRaydium()} /> {/* Future */}
```

### Fallback Systems
Handle protocol downtime gracefully:

```tsx
const primaryProvider = createJupiter()
const fallbackProvider = createRaydium() // Future

try {
  return await primaryProvider.quote(params)
} catch (error) {
  console.warn('Primary provider failed, using fallback')
  return await fallbackProvider.quote(params)
}
```

### Custom Integrations
Build protocol-specific features on standardized interfaces.

## Available Providers

### Jupiter
Jupiter is Solana's premier DEX aggregator, providing optimal routing across multiple liquidity sources.

- **Features**: Advanced routing, slippage protection, dynamic fees
- **Status**: âœ… Available  
- **Package**: `@arc/jupiter`

### Future Providers

The following providers are planned for future releases:

- **Raydium**: AMM and concentrated liquidity provider
- **Orca**: Whirlpools concentrated liquidity
- **Phoenix**: Central limit order book
- **Kamino**: Leveraged yield farming

## Centralized Provider Access

Import all providers from a single package:

```tsx
import { createJupiter } from '@connectorkit/jupiter'
import { createProvider } from '@connectorkit/hooks'

// Create multiple providers at once
const providers = createProviders({
  jupiter: { slippageBps: 50 }
  // Future: kamino: { /* config */ }
})

// Or import individually
import { createJupiter } from '@arc/jupiter'
```

## Multi-Provider Routing

Use multiple providers for optimal routing and redundancy:

```tsx
import { createJupiter } from '@arc/jupiter'

function MultiProviderSwap() {
  const providers = [
    createJupiter({ slippageBps: 50 }),
    // createRaydium({ slippageBps: 50 }),  // Future
  ]

  const findBestQuote = async (inputMint: string, outputMint: string, amount: bigint) => {
    // Get quotes from all providers
    const quotes = await Promise.allSettled(
      providers.map(provider => 
        provider.quote({ inputMint, outputMint, amount })
      )
    )

    // Find the quote with highest output amount
    const validQuotes = quotes
      .filter((result): result is PromiseFulfilledResult<any> => 
        result.status === 'fulfilled'
      )
      .map(result => result.value)

    return validQuotes.reduce((best, current) => 
      current.outputAmount > best.outputAmount ? current : best
    )
  }

  return <div>Multi-provider routing enabled</div>
}
```

## Creating Custom Providers

Build your own provider following the `SwapProvider` interface:

```tsx
import type { SwapProvider, SwapParams, SwapQuote, SwapBuild } from '@connectorkit/hooks'

export interface CustomConfig {
  apiUrl?: string
  slippageBps?: number
}

export function createCustomProvider(config: CustomConfig = {}): SwapProvider {
  return {
    name: 'custom-dex',
    
    async quote(params: SwapParams): Promise<SwapQuote> {
      // Fetch quote from your protocol's API
      const response = await fetch(`${config.apiUrl}/quote`, {
        method: 'POST',
        body: JSON.stringify({
          inputMint: params.inputMint,
          outputMint: params.outputMint,
          amount: params.amount.toString(),
          slippage: config.slippageBps || 50
        })
      })
      
      const data = await response.json()
      
      return {
        provider: 'custom-dex',
        inputMint: params.inputMint,
        outputMint: params.outputMint,
        inputAmount: params.amount,
        outputAmount: BigInt(data.outputAmount),
        priceImpact: data.priceImpact,
        fees: BigInt(data.fees),
        route: data, // Store full response for build step
      }
    },
    
    async build({ quote, userPublicKey }): Promise<SwapBuild> {
      // Build transaction from quote data
      const response = await fetch(`${config.apiUrl}/swap`, {
        method: 'POST',
        body: JSON.stringify({
          quote: quote.route,
          userPublicKey
        })
      })
      
      const { transaction } = await response.json()
      
      return {
        kind: 'prebuilt',
        transaction: { wireTransaction: new Uint8Array(transaction) }
      }
    },
    
    isTokenSupported(mint: string): boolean {
      // Check if token is supported by your protocol
      return true // Implementation specific
    }
  }
}
```

## Provider Template

See the [provider template](https://github.com/your-org/arc/blob/main/packages/providers/src/templates/provider-template.md) for a complete step-by-step guide to adding new providers to the `@connectorkit/providers` package.

## Installation

```bash
# Install specific providers
npm install @arc/jupiter

# Or install the providers package for centralized access
npm install @connectorkit/providers
```

## Provider Interface

All providers implement the `SwapProvider` interface:

```tsx
interface SwapProvider {
  name: string
  quote(params: SwapParams): Promise<SwapQuote>
  build(params: BuildParams): Promise<SwapBuild>
  isTokenSupported(mint: string): boolean
}

interface SwapParams {
  inputMint: string
  outputMint: string 
  amount: bigint
  slippageBps?: number
}

interface SwapQuote {
  provider: string
  inputMint: string
  outputMint: string
  inputAmount: bigint
  outputAmount: bigint
  priceImpact: number
  fees: bigint
  route: any // Provider-specific routing data
  effectiveSlippageBps?: number
}
```

This standardized interface ensures consistent behavior across all protocols while allowing provider-specific optimizations and features.